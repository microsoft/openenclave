// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/* Generated with: openssl genrsa -out private.pem -3 3072 */
static const char RSA_PRIVATE_KEY[] =
    "-----BEGIN RSA PRIVATE KEY-----\n"
    "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\n"
    "-----END RSA PRIVATE KEY-----\n";

/* Generated with: openssl rsa -in private.pem -pubout -out public.pem */
static const char RSA_PUBLIC_KEY[] =
    "-----BEGIN PUBLIC KEY-----\n"
    "MIIBoDANBgkqhkiG9w0BAQEFAAOCAY0AMIIBiAKCAYEAyXKod6+poFfDaMIT6dKe\n"
    "zZG/OeYSSvo2Nw7ufOtBCUrNaXOc5jIi1swpSASOx9nm3aYNeUGCPjDPads+YkSs\n"
    "o8Bmm4HzAR51/4rSt5/fjD5PVMpM4GozwbXSCsK8TjgVcQ3pthk16GgVpL0k1+G4\n"
    "abe+RYZKrS3KFwAT4Uk1ic+NcafKPwRo5uEs2YjX3aj0DiA/O3n95zMQoxsqwgbZ\n"
    "7dzhLfw0gkljr+Bj07Z+w/RUTYFo0OJ/QwW8A5iT5DxOaVvuf2hjbf8462xivQyv\n"
    "Ph9RH15ARvDYrMzdbDwW6Xpz7c+g61+AFtl64wYJDvD6nIkimyjYEcJRLtLeEdds\n"
    "ySqxPVv1Ki9KMlLFwKNnm8J8Pw5KeZ29YucZP95tPOXcPv6tx9/Sx8W21FNPzKrg\n"
    "oxlRJE9M8TDwh+qIxiwy9ComvBat1/px0fFwcSM+3MYG5s0TCsLp56mkn7aiv09e\n"
    "sqkFL5inQfbToVbB8FDxu0o9VUVax6A3V+xJh0yGeD/RAgED\n"
    "-----END PUBLIC KEY-----\n";

static const char ALPHABET[] = "abcdefghijklmnopqrstuvwxyz";

/* Hash of ALPHABET string above */
static OE_SHA256 HASH = {{
    0x71, 0xc4, 0x80, 0xdf, 0x93, 0xd6, 0xae, 0x2f, 0x1e, 0xfa, 0xd1,
    0x44, 0x7c, 0x66, 0xc9, 0x52, 0x5e, 0x31, 0x62, 0x18, 0xcf, 0x51,
    0xfc, 0x8d, 0x9e, 0xd8, 0x32, 0xf2, 0xda, 0xf1, 0x8b, 0x73,
}};

/* Signature of HASH using RSA_PRIVATE_KEY */
static const uint8_t RSA_SIGNATURE[] = {
    0x65, 0x98, 0x25, 0xBA, 0xE8, 0x08, 0xAF, 0x10, 0xC0, 0xAC, 0xDF, 0xAB,
    0x83, 0x65, 0x8D, 0x6E, 0xE8, 0x36, 0x42, 0xAC, 0x01, 0x4B, 0x5D, 0x9E,
    0xF0, 0x26, 0xB3, 0x25, 0x46, 0x4D, 0xD3, 0xC7, 0xB6, 0x4D, 0xA3, 0xCB,
    0xC6, 0x51, 0x12, 0xD5, 0xC9, 0x14, 0x35, 0xB1, 0x7A, 0x3C, 0xD6, 0x19,
    0xF2, 0x7F, 0xD4, 0x4B, 0x1C, 0x66, 0x56, 0xC4, 0xFE, 0x06, 0xDB, 0x86,
    0xDF, 0x69, 0x87, 0x8D, 0x47, 0x1F, 0x69, 0x74, 0xCA, 0xF6, 0x16, 0x3F,
    0x81, 0xF7, 0xD5, 0x34, 0xBB, 0xEE, 0xE1, 0xA9, 0x7E, 0x06, 0xCF, 0x21,
    0x44, 0x76, 0x83, 0xA1, 0xF1, 0x56, 0xC6, 0x06, 0x07, 0xFE, 0xA1, 0x19,
    0x66, 0xF1, 0xAB, 0x4E, 0xFC, 0xFD, 0xC9, 0x6B, 0x2D, 0x29, 0x6E, 0xE4,
    0xBA, 0x56, 0xD6, 0x65, 0x88, 0xA4, 0x8B, 0x38, 0x41, 0xC6, 0x50, 0x38,
    0xAB, 0x1D, 0x61, 0xB9, 0x12, 0xCE, 0x00, 0x45, 0x5B, 0x52, 0xC7, 0xE2,
    0x91, 0x3A, 0xAE, 0xC3, 0xAC, 0xC9, 0x6F, 0xBD, 0xB2, 0x0D, 0xCC, 0xAF,
    0xD8, 0x58, 0xC8, 0x38, 0x02, 0xEA, 0xA5, 0xD4, 0x9C, 0x80, 0x9F, 0xA3,
    0x8C, 0xCE, 0x78, 0xA4, 0xE5, 0xFB, 0x0D, 0xF0, 0x1B, 0xF6, 0x58, 0xBB,
    0xF0, 0xC8, 0xEB, 0x2E, 0x97, 0x47, 0x31, 0x5E, 0xDA, 0xDD, 0x2F, 0x1E,
    0x14, 0x07, 0x91, 0xB0, 0x01, 0xB8, 0x00, 0xF3, 0xD9, 0xD1, 0x94, 0xAC,
    0x46, 0x84, 0x45, 0x99, 0x70, 0x59, 0x4B, 0x01, 0x32, 0x20, 0x11, 0x23,
    0x01, 0x6E, 0xC7, 0xD8, 0x3E, 0x37, 0xC5, 0xB1, 0x03, 0xA6, 0xE6, 0xC4,
    0x0D, 0x36, 0x8C, 0x0A, 0xCA, 0xC1, 0xF1, 0x9D, 0xF7, 0xF5, 0xCD, 0x92,
    0x60, 0x5B, 0x31, 0x94, 0x3B, 0xA4, 0xBD, 0xEE, 0xD3, 0xE4, 0x2F, 0xF5,
    0x8F, 0x61, 0x10, 0x13, 0xE5, 0xE3, 0x5A, 0x58, 0xC7, 0x36, 0x4D, 0xBD,
    0x00, 0x85, 0x54, 0x34, 0x34, 0x7E, 0x05, 0x01, 0xFE, 0xE8, 0x76, 0xB9,
    0x20, 0x09, 0x5F, 0x37, 0xF7, 0x38, 0x57, 0xE0, 0x35, 0xB6, 0x62, 0xD2,
    0x1B, 0x23, 0xE0, 0xCC, 0xE1, 0x1A, 0x29, 0x3D, 0x76, 0x18, 0xDB, 0x6A,
    0x7A, 0x9A, 0x08, 0xD4, 0x2E, 0x38, 0x6C, 0x0F, 0xE2, 0x93, 0x2E, 0x5B,
    0x4B, 0xE4, 0x88, 0x72, 0xA8, 0x0D, 0x3E, 0xD3, 0x4A, 0xCA, 0x1E, 0xDB,
    0x5C, 0x39, 0x88, 0x57, 0xBD, 0x53, 0xCB, 0x1C, 0x60, 0xC2, 0xAD, 0x8B,
    0x59, 0x1F, 0x3E, 0xC0, 0xC1, 0x6C, 0x3C, 0x1A, 0x5A, 0x72, 0xE1, 0x86,
    0xAB, 0xA3, 0xB3, 0x56, 0xA8, 0x0D, 0xB1, 0xAA, 0x1F, 0xB8, 0x15, 0x86,
    0x52, 0xBF, 0x24, 0x8B, 0xD4, 0x52, 0x26, 0x92, 0x2C, 0xCC, 0x90, 0x86,
    0x62, 0x9D, 0x1C, 0x09, 0x85, 0xEB, 0x2C, 0x11, 0xCD, 0xDF, 0xD1, 0xDA,
    0x68, 0xA8, 0x08, 0xE8, 0xF1, 0x10, 0xFB, 0x78, 0xDA, 0x7E, 0xB3, 0x56,
};

static const size_t RSA_SIGNATURE_SIZE = sizeof(RSA_SIGNATURE);

// Test computation of SHA-256 hash over an ASCII alphabet string.
static void TestSHA256()
{
    printf("=== begin TestSHA25\n");

    OE_SHA256 hash;
    OE_SHA256Context ctx;
    OE_SHA256Init(&ctx);
    OE_SHA256Update(&ctx, ALPHABET, strlen(ALPHABET));
    OE_SHA256Final(&ctx, &hash);
    OE_TEST(memcmp(&hash, &HASH, sizeof(OE_SHA256)) == 0);

    printf("=== passed TestSHA25\n");
}

// Test RSA signing operation over an ASCII alphabet string.
static void TestRSASign()
{
    printf("=== begin TestRSASign\n");

    OE_Result r;
    OE_RSAPrivateKey key;
    uint8_t* signature = NULL;
    size_t signatureSize = 0;

    r = OE_RSAReadPrivateKeyPEM(
        (const uint8_t*)RSA_PRIVATE_KEY, sizeof(RSA_PRIVATE_KEY), &key);
    OE_TEST(r == OE_OK);

    r = OE_RSASign(
        &key,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_BUFFER_TOO_SMALL);

    OE_TEST(signature = (uint8_t*)malloc(signatureSize));

    r = OE_RSASign(
        &key,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_OK);

    OE_TEST(signatureSize == RSA_SIGNATURE_SIZE);
    OE_TEST(memcmp(signature, &RSA_SIGNATURE, RSA_SIGNATURE_SIZE) == 0);

#if 0
    OE_HexDump(signature, signatureSize);
#endif

    free(signature);

    printf("=== passed TestRSASign\n");
}

// Test RSA verify operation over an ASCII alphabet string.
static void TestRSAVerify()
{
    OE_Result r;
    OE_RSAPublicKey key;

    r = OE_RSAReadPublicKeyPEM(
        (const uint8_t*)RSA_PUBLIC_KEY, sizeof(RSA_PUBLIC_KEY), &key);
    OE_TEST(r == OE_OK);

    r = OE_RSAVerify(
        &key,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        RSA_SIGNATURE,
        RSA_SIGNATURE_SIZE);
    OE_TEST(r == OE_OK);

    printf("=== passed TestRSAVerify\n");
}

static const char CERT[] =
    "-----BEGIN CERTIFICATE-----\n"
    "MIIDMzCCAhsCAhABMA0GCSqGSIb3DQEBCwUAMGMxGjAYBgNVBAMMEVRlc3QgSW50\n"
    "ZXJtZWRpYXRlMQ4wDAYDVQQIDAVUZXhhczELMAkGA1UEBhMCVVMxEjAQBgNVBAoM\n"
    "CU1pY3Jvc29mdDEUMBIGA1UECwwLT3BlbkVuY2xhdmUwHhcNMTgwMjEzMTc1MjUz\n"
    "WhcNMTkwMjEzMTc1MjUzWjBbMRIwEAYDVQQDDAlUZXN0IExlYWYxDjAMBgNVBAgM\n"
    "BVRleGFzMQswCQYDVQQGEwJVUzESMBAGA1UECgwJTWljcm9zb2Z0MRQwEgYDVQQL\n"
    "DAtPcGVuRW5jbGF2ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOjL\n"
    "A0tUP/Sw+L9KowKL94PJe2Bk9u0YeeRa0z1PyIoLVE3KCeOLQueo7gQwah0s/ZA1\n"
    "53lggkyt3VjMOUC5FBS5hy79VcoInrrS9DG8PtZBk3AobDcUBNipWIJ5lofijppi\n"
    "uRFfr4HtMN9TYJhfWnau7puep5X/HeW0k3/Hox8+R6Gdu74QkTILVrDh6EcXzLUv\n"
    "XXFu0bi/pDhoBeW+HGxK8ot+wjKt/NjnYc3KlrNQVDzBDEpXx5enWFbow37O6Rab\n"
    "+iHCkvOYvJe1tgJTpI65Qi688Xc3/NFzZ3lA3PET+xKjjzBS1wHrumCu9L3ugJJ3\n"
    "ZVHwHlDQ9u9qTRHlGYcCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAlP9O97ydoazt\n"
    "w4oGluwo3Wef9O2Nx6OhNqY+lrCx/KkdBHVqGLaveo6UDlkRQLydyx55ekrMdatG\n"
    "UyzFm6JTAh29R7ocTWdERmNLQNR1yQFCr0JJ1yPHucikY7ubD0iIxlAliPKPsH/S\n"
    "t4pff8GRRrv5+jCON6zT2lX+ZVOCwyolu5oZWFI6iWy6JldYdaHhmiy3gP/F2abr\n"
    "NASwM79RRO+JGskwgswboXp8Tg83jzdbSe6DL6LfK0UgpeEr3QtNhDMkw7KY1oXs\n"
    "7WxpjlnJCyCkAW0c5+Hh2WgZLwYXcfRXer6WuugAz6WPayLDsHf0ZqiuiVjkbS1l\n"
    "ln6O0i8HeQ==\n"
    "-----END CERTIFICATE-----\n";

static const char CHAIN[] =
    "-----BEGIN CERTIFICATE-----\n"
    "MIIDUDCCAjgCCQDNkOt+e8l1aDANBgkqhkiG9w0BAQsFADBqMQswCQYDVQQGEwJV\n"
    "UzEOMAwGA1UECAwFVGV4YXMxDzANBgNVBAcMBkF1c3RpbjESMBAGA1UECgwJTWlj\n"
    "cm9zb2Z0MRQwEgYDVQQLDAtPcGVuRW5jbGF2ZTEQMA4GA1UEAwwHVGVzdCBDQTAe\n"
    "Fw0xODAyMTMxNzUyNTJaFw0yMzAyMTMxNzUyNTJaMGoxCzAJBgNVBAYTAlVTMQ4w\n"
    "DAYDVQQIDAVUZXhhczEPMA0GA1UEBwwGQXVzdGluMRIwEAYDVQQKDAlNaWNyb3Nv\n"
    "ZnQxFDASBgNVBAsMC09wZW5FbmNsYXZlMRAwDgYDVQQDDAdUZXN0IENBMIIBIjAN\n"
    "BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlrzZNtYmicG/Z0ZK0qYzmTyur/n4\n"
    "94fkDBklgsHb9inbe455MgUsIcrlwE/1qXbcO0SnQmUjmopE2iYJhDVDDnobgDlP\n"
    "iO1o8E7tIW/jzxRStDyfrO6uOrc8mUAvnsHc800d2Dt6vAHhdbiBeIi8CkIgy5/h\n"
    "XXQphjk9H0jrVFydJ7KYl53KvwZ95NAodPZpiuCD6WXDEvXOLvQaup2nG9+ha5QB\n"
    "h0pfdNRhHtsfIcg5ExghoOYXcOhCtEqkVYcllmYr2tf3tn/dRVXO7KYbfqr/mQo+\n"
    "oPfhziAyyKHxx7a6bfDngV8ORI7q9b774VgZd3dTDDYechYTIH5V4pX61QIDAQAB\n"
    "MA0GCSqGSIb3DQEBCwUAA4IBAQBbCNHoUIVpUnLhrugyooDCygYQeTebVILY1DHG\n"
    "Kj7GEpMK70suXQlJ7/hbuL8jTA/kHMtHARy+9DAQDjiWRfRNOpE4eEbUdEiwei4L\n"
    "2tPke58FBxkq6GcpldPBin16ux379zM43vYwhEf9yuY6KwBfaABg6Eeftrpcuvt3\n"
    "1Ibbn4oM2MZixhZXTkKsB3O1OlaZ/kw6qPt7LklLhij1SmvtrrlkWGWoAg8JWYh+\n"
    "+Wd1yIgPZbbio9b4rgQ6j0mpWaRVPm7cKAt3nfhnMgr1QV+RQnPDTlsO+sieCLZm\n"
    "Z/7gtSYO0BbJnQu3dXzP0OBD1SQvQOpjWXwC71ioBn1rbqDl\n"
    "-----END CERTIFICATE-----\n"
    "-----BEGIN CERTIFICATE-----\n"
    "MIIDQjCCAioCAhAAMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNVBAYTAlVTMQ4wDAYD\n"
    "VQQIDAVUZXhhczEPMA0GA1UEBwwGQXVzdGluMRIwEAYDVQQKDAlNaWNyb3NvZnQx\n"
    "FDASBgNVBAsMC09wZW5FbmNsYXZlMRAwDgYDVQQDDAdUZXN0IENBMB4XDTE4MDIx\n"
    "MzE3NTI1M1oXDTE5MDIxMzE3NTI1M1owYzEaMBgGA1UEAwwRVGVzdCBJbnRlcm1l\n"
    "ZGlhdGUxDjAMBgNVBAgMBVRleGFzMQswCQYDVQQGEwJVUzESMBAGA1UECgwJTWlj\n"
    "cm9zb2Z0MRQwEgYDVQQLDAtPcGVuRW5jbGF2ZTCCASIwDQYJKoZIhvcNAQEBBQAD\n"
    "ggEPADCCAQoCggEBALtrsdnSA0135a5Ry0BlAoiCuvMS4ttmKrG5aNqq1QtXT0rr\n"
    "eeVs7uCu43DeuBjoPDCe113LIse68o0VfpyGoEB4k5IEftwNuqt/s9YPnpCjIPw0\n"
    "tJIhf/0iNo2HXDK7KVkHnjPTcS1KVlWrnVABP7+Q80nBj7S9yxv7LMuKEzU/NSgG\n"
    "TZZWbIDh8DnTvG2YCz9XAtPjBjWAICDOh4Hlkujt2Z/9D3/At3yL577VBBngZG0A\n"
    "wCJYE+SpibP8d/f0tuFa6vhNzsDxwqYmBLU1CL1G+3brlCTgfSUCzxC/RSu5lJGo\n"
    "fZ7E/0s1+kY07p7iiLCgMOJCBIUE+NP2aX8WSRsCAwEAATANBgkqhkiG9w0BAQsF\n"
    "AAOCAQEAWHmQ3uAggLQY/G0Idzk+HhxRArgLXvd4nAlELlArngTGviuZBdcjQhIA\n"
    "Do/5GUcoBHLI3Q7lspbT9kbn+2664Gm5jh7A9OU/kpFpMQT+e6aTUDPTlLuHygpx\n"
    "bP4X6hn+D5QEBct/befUKcAMZGya46N+m+qWJbH+fplkA2zuZ4NdXav21BsqXRer\n"
    "JN6pIxewAEhYGt8nd5mjRFJnMfb6IWs49TRxvk7SntVrWktW36TxPTTWsusuCd8v\n"
    "RGTsgD4AIHqFRVi+e+y32K9xxUL4f27s6wSu+f2z2oAQsrfuhHyFMUZT4NLs4KAk\n"
    "QbVRkhj9vYJrIP8rRJ+XV9j/IvfdjQ==\n"
    "-----END CERTIFICATE-----\n";

static const char BAD_CHAIN[] =
    "-----BEGIN CERTIFICATE-----\n"
    "MIIDUDCCAjgCCQCCncn7BEtWSzANBgkqhkiG9w0BAQsFADBqMQswCQYDVQQGEwJV\n"
    "UzEOMAwGA1UECAwFVGV4YXMxDzANBgNVBAcMBkF1c3RpbjESMBAGA1UECgwJTWlj\n"
    "cm9zb2Z0MRQwEgYDVQQLDAtPcGVuRW5jbGF2ZTEQMA4GA1UEAwwHVGVzdCBDQTAe\n"
    "Fw0xODAyMTMwMTQwMDhaFw0yMzAyMTMwMTQwMDhaMGoxCzAJBgNVBAYTAlVTMQ4w\n"
    "DAYDVQQIDAVUZXhhczEPMA0GA1UEBwwGQXVzdGluMRIwEAYDVQQKDAlNaWNyb3Nv\n"
    "ZnQxFDASBgNVBAsMC09wZW5FbmNsYXZlMRAwDgYDVQQDDAdUZXN0IENBMIIBIjAN\n"
    "BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwSnztYAKE2Mq5XL2dCZsFGKsMjsr\n"
    "pIK37PoBEPJsphL8jrpbRtYklp5HpIpcakT0poL34p90xaW+bIthzbU/MOC/2A/0\n"
    "63WS4v4n2h33JaMoGVQ4qt+4sV6sZwG70ifbG6linQQAfhdzt+7hxizLr0sh+gys\n"
    "/E5qkik87pwb2NxDc4tO5vybq50AKf+UVBC5/f//YD0LrXYafUVEruwsCj9fAjso\n"
    "vAhPqn4nVylOwuNBCjXGkLNF/Rxsi25Cb8rX0rMS1/evjTaTveMRtVYJP4OnDuWL\n"
    "SzksoGwC4D4hb2SNB+QEMyGv1SnrrmfEXdN/RKf3pCtFJigskcxy/3jgnwIDAQAB\n"
    "MA0GCSqGSIb3DQEBCwUAA4IBAQABen8yc7HPFjqi+xuiwh+3YcVOYOd5R+gVdsPm\n"
    "1VLcetXOVx1aRjHF9jwkF3GzQ5UbKex9MSiScjDjLV9ukmJD+HjMwAm3W/Rex+rY\n"
    "Y7bM6uvKN5zxs5SeuO7odkYP2jHlSnozMJt7jMENr2sJUscIrn073Z3b0gLcv/Cb\n"
    "QKQY5OSmyQYYu7ib14SxcpIjdZi1T/PH8hlKaKsdt+OFTzA3t8VdN69jZSubwP+A\n"
    "gBmiW1o/q+r+pN3woaClk5c0/Dh9t/xJcNth4NSKV/YrLHQLZQ76SvICtKexz1RZ\n"
    "wZSQ03dKw87xW3t3f5GS3O75zDNeT4TMeYd4RMRiK6wDt2WE\n"
    "-----END CERTIFICATE-----\n"
    "-----BEGIN CERTIFICATE-----\n"
    "MIIDQjCCAioCAhAAMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNVBAYTAlVTMQ4wDAYD\n"
    "VQQIDAVUZXhhczEPMA0GA1UEBwwGQXVzdGluMRIwEAYDVQQKDAlNaWNyb3NvZnQx\n"
    "FDASBgNVBAsMC09wZW5FbmNsYXZlMRAwDgYDVQQDDAdUZXN0IENBMB4XDTE4MDIx\n"
    "MzAxNDAwOFoXDTE5MDIxMzAxNDAwOFowYzEaMBgGA1UEAwwRVGVzdCBJbnRlcm1l\n"
    "ZGlhdGUxDjAMBgNVBAgMBVRleGFzMQswCQYDVQQGEwJVUzESMBAGA1UECgwJTWlj\n"
    "cm9zb2Z0MRQwEgYDVQQLDAtPcGVuRW5jbGF2ZTCCASIwDQYJKoZIhvcNAQEBBQAD\n"
    "ggEPADCCAQoCggEBALlie2zjCfdy1fckjuM7kXf7CkyVp+hqhkJMUU80ETP8AM2R\n"
    "JsJ2Xkvdf8GrIl93lQU9f9O+HRl45O2M/zz2ZTucDF6dWvJ4yCDUWOwE2ro8eh3d\n"
    "0BRJvzjs/wgt10v5KJaHnMu9wYVn/8gLWOS/qLwVnPxzqQ507GwOdNaOSHiWXYc9\n"
    "fl062HLXirLaKMPx5ZD2QlXDPYQta+lbTHWDReelDNHT3G8FtiKtzQ0uT2EWLw7z\n"
    "dOu61+EGf2PdqZc+2MVTPca/qO+cCSwzdzGzOQgUYmtn6YUN1y/GJv73AbnPazvY\n"
    "fVysQanSa1g+LD9WFjF4qInlTnCvjvKQEeqGiTsCAwEAATANBgkqhkiG9w0BAQsF\n"
    "AAOCAQEAmABx/BVWs4w8bfU0ce5Yj9RYWziMilhrEZJgCmSQzNlNO7DNcPthBbNi\n"
    "OAgd8y+lSpcHk5KJ9tm9rD6G+0RbL+8M1TyagrI0M++7Ex2gZV9DSEtvBqnl8XgS\n"
    "tlb2xW0x2jol9MdQrsaCcORbrEnogP8YGzICMoJQ8OiJed99PS7q+eQ0lW9A7e+o\n"
    "XJ9PjI7n93Wou0xC4kYOszGPGIZ9X5mEPAKqqCcXsxGfruDrgmulB526hb/lHC/5\n"
    "1gRic7SCYsyWgxde7R5D+IxxcJNnIWNnt3TUIT8I9fbwonddxA3Qln9tr784dDiB\n"
    "/c5qUrfE7k0DrKr4OZvt/xbV9oKMyg==\n"
    "-----END CERTIFICATE-----\n";

static void TestCertVerifyGood()
{
    printf("=== begin TestCertVerifyGood()\n");

    OE_Result r;
    OE_VerifyCertError error;
    OE_Cert cert;
    OE_CertChain chain;
    OE_CRL* crl = NULL;

    r = OE_CertReadPEM(CERT, sizeof(CERT), &cert);
    OE_TEST(r == OE_OK);

    r = OE_CertChainReadPEM(CHAIN, sizeof(CHAIN), &chain);
    OE_TEST(r == OE_OK);

    r = OE_CertVerify(&cert, &chain, crl, &error);
    OE_TEST(r == OE_OK);

    OE_CertFree(&cert);
    OE_CertChainFree(&chain);

    printf("=== passed TestCertVerifyGood()\n");
}

static void TestCertVerifyBad()
{
    printf("=== begin TestCertVerifyBad()\n");

    OE_Result r;
    OE_VerifyCertError error;
    OE_Cert cert;
    OE_CertChain chain;
    OE_CRL* crl = NULL;

    r = OE_CertReadPEM(CERT, sizeof(CERT), &cert);
    OE_TEST(r == OE_OK);

    /* Chain does not contain a root for this certificate */
    r = OE_CertChainReadPEM(BAD_CHAIN, sizeof(BAD_CHAIN), &chain);
    OE_TEST(r == OE_OK);

    r = OE_CertVerify(&cert, &chain, crl, &error);
    OE_TEST(r == OE_VERIFY_FAILED);

    OE_CertFree(&cert);
    OE_CertChainFree(&chain);

    printf("=== passed TestCertVerifyBad()\n");
}

static void TestCertVerify()
{
    printf("=== begin TestCertVerify()\n");

    TestCertVerifyGood();
    TestCertVerifyBad();

    printf("=== passed TestCertVerifyCert()\n");
}

static void TestRandom()
{
    printf("=== begin TestRandom()\n");

    static const size_t N = 64;
    static const size_t M = 19;
    uint8_t buf[N][M];

    memset(buf, 0, sizeof(buf));

    for (size_t i = 0; i < N; i++)
    {
        /* Generate a random sequence */
        OE_TEST(OE_Random(buf[i], M * sizeof(uint8_t)) == OE_OK);

#if 0
        OE_HexDump(buf[i], M * sizeof(uint8_t));
#endif

        /* Be sure buffer is not filled with same character */
        {
            size_t m;
            uint8_t c = buf[i][0];

            for (m = 1; m < M && buf[i][m] == c; m++)
                ;

            OE_TEST(m != M);
        }

        /* Check whether duplicate of one of the previous calls */
        for (size_t j = 0; j < i; j++)
        {
            OE_TEST(memcmp(buf[j], buf[i], M * sizeof(uint8_t)) != 0);
        }
    }

    printf("=== passed TestRandom()\n");
}

static const char EC_PRIVATE_KEY[] =
    "-----BEGIN EC PRIVATE KEY-----\n"
    "MHQCAQEEIKVVUe1F/MxIp6jmrZ24/8iI6WTj1QDamxZLHQ8ZbL4woAcGBSuBBAAK\n"
    "oUQDQgAEmAxYbaM1rpk+d1KX5pHn0GuuaL5wgEA8xoLzHqVcX1dCOyN1rnZP9axj\n"
    "h8t36IjqPhnxNvCPruzBq/KRbbpIZA==\n"
    "-----END EC PRIVATE KEY-----\n";

static const char EC_PUBLIC_KEY[] =
    "-----BEGIN PUBLIC KEY-----\n"
    "MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEmAxYbaM1rpk+d1KX5pHn0GuuaL5wgEA8\n"
    "xoLzHqVcX1dCOyN1rnZP9axjh8t36IjqPhnxNvCPruzBq/KRbbpIZA==\n"
    "-----END PUBLIC KEY-----\n";

static const uint8_t EC_SIGNATURE[] = {
    0x30, 0x45, 0x02, 0x21, 0x00, 0x89, 0x3a, 0xf7, 0xe5, 0xf2, 0x21, 0xe1,
    0xf9, 0xdc, 0xe0, 0x92, 0x82, 0xe6, 0xe4, 0xec, 0xcc, 0x68, 0x6d, 0x00,
    0x5d, 0x0e, 0x9c, 0xd5, 0x08, 0x48, 0x8b, 0x09, 0x5f, 0x20, 0xee, 0xbe,
    0x95, 0x02, 0x20, 0x6e, 0xaa, 0xd2, 0x15, 0xf9, 0xf3, 0xaa, 0xc2, 0x19,
    0xc5, 0x4c, 0x44, 0x0b, 0xa7, 0x2c, 0x3e, 0xe9, 0xc3, 0xb6, 0xf3, 0xb4,
    0x04, 0x51, 0xc6, 0xe9, 0xf1, 0x69, 0x46, 0xb0, 0x3e, 0x22, 0xe6,
};

static size_t EC_SIGNATURE_SIZE = sizeof(EC_SIGNATURE);

// Test EC signing operation over an ASCII alphabet string. Note that two
// signatures over the same data produce different hex sequences, although
// signature verification will still succeed.

static void TestECSignAndVerify()
{
    printf("=== begin TestECSignAndVerify()\n");

    uint8_t* signature = NULL;
    size_t signatureSize = 0;
    OE_Result r;

    {
        OE_ECPrivateKey key;

        r = OE_ECReadPrivateKeyPEM(
            (const uint8_t*)EC_PRIVATE_KEY, sizeof(EC_PRIVATE_KEY), &key);
        OE_TEST(r == OE_OK);

        r = OE_ECSign(
            &key,
            OE_HASH_TYPE_SHA256,
            &HASH,
            sizeof(HASH),
            signature,
            &signatureSize);
        OE_TEST(r == OE_BUFFER_TOO_SMALL);

        OE_TEST(signature = (uint8_t*)malloc(signatureSize));

        r = OE_ECSign(
            &key,
            OE_HASH_TYPE_SHA256,
            &HASH,
            sizeof(HASH),
            signature,
            &signatureSize);
        OE_TEST(r == OE_OK);

        OE_TEST(signature != NULL);
        OE_TEST(signatureSize != 0);
    }

    {
        OE_ECPublicKey key;

        r = OE_ECReadPublicKeyPEM(
            (const uint8_t*)EC_PUBLIC_KEY, sizeof(EC_PUBLIC_KEY), &key);
        OE_TEST(r == OE_OK);

        r = OE_ECVerify(
            &key,
            OE_HASH_TYPE_SHA256,
            &HASH,
            sizeof(HASH),
            signature,
            signatureSize);
        OE_TEST(r == OE_OK);

        r = OE_ECVerify(
            &key,
            OE_HASH_TYPE_SHA256,
            &HASH,
            sizeof(HASH),
            EC_SIGNATURE,
            EC_SIGNATURE_SIZE);
        OE_TEST(r == OE_OK);
    }

#if 0
    OE_HexDump(signature, signatureSize);
#endif

    free(signature);

    printf("=== passed TestECSignAndVerify()\n");
}

static void TestRSAGenerate()
{
    printf("=== begin TestRSAGenerate()\n");

    OE_Result r;
    OE_RSAPrivateKey privateKey;
    OE_RSAPublicKey publicKey;
    uint8_t* signature = NULL;
    size_t signatureSize = 0;

    r = OE_RSAGenerate(1024, 3, &privateKey, &publicKey);
    OE_TEST(r == OE_OK);

    r = OE_RSASign(
        &privateKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_BUFFER_TOO_SMALL);

    OE_TEST(signature = (uint8_t*)malloc(signatureSize));

    r = OE_RSASign(
        &privateKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_OK);

    r = OE_RSAVerify(
        &publicKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        signatureSize);
    OE_TEST(r == OE_OK);

    free(signature);
    OE_RSAFreePrivateKey(&privateKey);
    OE_RSAFreePublicKey(&publicKey);

    printf("=== passed TestRSAGenerate()\n");
}

static void TestECGenerate()
{
    printf("=== begin TestECGenerate()\n");

    OE_Result r;
    OE_ECPrivateKey privateKey;
    OE_ECPublicKey publicKey;
    uint8_t* signature = NULL;
    size_t signatureSize = 0;

    r = OE_ECGenerate(OE_EC_TYPE_SECP521R1, &privateKey, &publicKey);
    OE_TEST(r == OE_OK);

    r = OE_ECSign(
        &privateKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_BUFFER_TOO_SMALL);

    OE_TEST(signature = (uint8_t*)malloc(signatureSize));

    r = OE_ECSign(
        &privateKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        &signatureSize);
    OE_TEST(r == OE_OK);

    r = OE_ECVerify(
        &publicKey,
        OE_HASH_TYPE_SHA256,
        &HASH,
        sizeof(HASH),
        signature,
        signatureSize);
    OE_TEST(r == OE_OK);

    free(signature);
    OE_ECFreePrivateKey(&privateKey);
    OE_ECFreePublicKey(&publicKey);

    printf("=== passed TestECGenerate()\n");
}

static void TestRSAWritePrivate()
{
    printf("=== begin TestRSAWritePrivate()\n");

    OE_Result r;
    OE_RSAPrivateKey key;
    void* pemData = NULL;
    size_t pemSize = 0;

    r = OE_RSAReadPrivateKeyPEM(
        (const uint8_t*)RSA_PRIVATE_KEY, sizeof(RSA_PRIVATE_KEY), &key);
    OE_TEST(r == OE_OK);

    r = OE_RSAWritePrivateKeyPEM(&key, pemData, &pemSize);
    OE_TEST(r == OE_BUFFER_TOO_SMALL);

    OE_TEST(pemData = (uint8_t*)malloc(pemSize));

    r = OE_RSAWritePrivateKeyPEM(&key, pemData, &pemSize);
    OE_TEST(r == OE_OK);

    OE_TEST(sizeof(RSA_PRIVATE_KEY) == pemSize);
    OE_TEST(memcmp(RSA_PRIVATE_KEY, pemData, pemSize) == 0);

    free(pemData);
    OE_RSAFreePrivateKey(&key);

    printf("=== passed TestRSAWritePrivate()\n");
}

static void TestRSAWritePublic()
{
    printf("=== begin TestRSAWritePublic()\n");

    OE_Result r;
    OE_RSAPublicKey key;
    void* pemData = NULL;
    size_t pemSize = 0;

    r = OE_RSAReadPublicKeyPEM(
        (const uint8_t*)RSA_PUBLIC_KEY, sizeof(RSA_PUBLIC_KEY), &key);
    OE_TEST(r == OE_OK);

    r = OE_RSAWritePublicKeyPEM(&key, pemData, &pemSize);
    OE_TEST(r == OE_BUFFER_TOO_SMALL);

    OE_TEST(pemData = (uint8_t*)malloc(pemSize));

    r = OE_RSAWritePublicKeyPEM(&key, pemData, &pemSize);
    OE_TEST(r == OE_OK);

    OE_TEST(sizeof(RSA_PUBLIC_KEY) == pemSize);
    OE_TEST(memcmp(RSA_PUBLIC_KEY, pemData, pemSize) == 0);

    free(pemData);
    OE_RSAFreePublicKey(&key);

    printf("=== passed TestRSAWritePublic()\n");
}

static void TestECWritePrivate()
{
    printf("=== begin TestECWritePrivate()\n");

    OE_Result r;
    OE_ECPublicKey publicKey;
    OE_ECPrivateKey key1;
    OE_ECPrivateKey key2;
    uint8_t* pemData1 = NULL;
    size_t pemSize1 = 0;
    uint8_t* pemData2 = NULL;
    size_t pemSize2 = 0;

    r = OE_ECGenerate(OE_EC_TYPE_SECP521R1, &key1, &publicKey);
    OE_TEST(r == OE_OK);

    {
        r = OE_ECWritePrivateKeyPEM(&key1, pemData1, &pemSize1);
        OE_TEST(r == OE_BUFFER_TOO_SMALL);

        OE_TEST(pemData1 = (uint8_t*)malloc(pemSize1));

        r = OE_ECWritePrivateKeyPEM(&key1, pemData1, &pemSize1);
        OE_TEST(r == OE_OK);
    }

    OE_TEST(pemSize1 != 0);
    OE_TEST(pemData1[pemSize1 - 1] == '\0');
    OE_TEST(strlen((char*)pemData1) == pemSize1 - 1);

    r = OE_ECReadPrivateKeyPEM(pemData1, pemSize1, &key2);
    OE_TEST(r == OE_OK);

    {
        r = OE_ECWritePrivateKeyPEM(&key2, pemData2, &pemSize2);
        OE_TEST(r == OE_BUFFER_TOO_SMALL);

        OE_TEST(pemData2 = (uint8_t*)malloc(pemSize2));

        r = OE_ECWritePrivateKeyPEM(&key2, pemData2, &pemSize2);
        OE_TEST(r == OE_OK);
    }

    OE_TEST(pemSize1 == pemSize2);
    OE_TEST(memcmp(pemData1, pemData2, pemSize1) == 0);

    free(pemData1);
    free(pemData2);
    OE_ECFreePublicKey(&publicKey);
    OE_ECFreePrivateKey(&key1);
    OE_ECFreePrivateKey(&key2);

    printf("=== passed TestECWritePrivate()\n");
}

static void TestECWritePublic()
{
    printf("=== begin TestECWritePublic()\n");

    OE_Result r;
    OE_ECPublicKey key;
    void* pemData = NULL;
    size_t pemSize = 0;

    r = OE_ECReadPublicKeyPEM(
        (const uint8_t*)EC_PUBLIC_KEY, sizeof(EC_PUBLIC_KEY), &key);
    OE_TEST(r == OE_OK);

    {
        r = OE_ECWritePublicKeyPEM(&key, pemData, &pemSize);
        OE_TEST(r == OE_BUFFER_TOO_SMALL);

        OE_TEST(pemData = (uint8_t*)malloc(pemSize));

        r = OE_ECWritePublicKeyPEM(&key, pemData, &pemSize);
        OE_TEST(r == OE_OK);
    }

    OE_TEST(sizeof(EC_PUBLIC_KEY) == pemSize);
    OE_TEST(memcmp(EC_PUBLIC_KEY, pemData, pemSize) == 0);

    free(pemData);
    OE_ECFreePublicKey(&key);

    printf("=== passed TestECWritePublic()\n");
}

static void RunAllTests()
{
    TestCertVerify();
    TestECGenerate();
    TestECSignAndVerify();
    TestECWritePrivate();
    TestECWritePublic();
    TestRandom();
    TestRSAGenerate();
    TestRSASign();
    TestRSAVerify();
    TestRSAWritePrivate();
    TestRSAWritePublic();
    TestSHA256();
}
