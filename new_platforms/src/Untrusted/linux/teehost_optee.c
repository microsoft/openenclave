/* Copyright (c) Microsoft Corporation. All rights reserved. */
/* Licensed under the MIT License. */
#include <stdlib.h>
#include <stddef.h>
#include <assert.h>

#include "sal_unsup.h"
#include <openenclave/host.h>
#include "optee.h"
#include "../oeshim_host.h"
#include "optee_common.h"

static TEEC_Result handle_generic_rpc(
    int type,
    void *input_buffer,
    size_t input_buffer_size,
    void *output_buffer,
    size_t output_buffer_size,
    void *context)
{
    oe_result_t result;
    struct tcps_optee_context *optee;

    optee = (struct tcps_optee_context *)context;

    if (type < V1_FUNCTION_ID_OFFSET) {
        /* Handle internal ECALL generated by oeedger8r. */
        if (type >= g_internal_ocall_table_v2.nr_ocall)
            return TEEC_ERROR_BAD_PARAMETERS;

        uint32_t bytes_written = 0;
        g_internal_ocall_table_v2.call_addr[type](
            input_buffer,
            input_buffer_size,
            output_buffer,
            output_buffer_size,
            &bytes_written);
        
        result = OE_OK;
    } else if (type < V2_FUNCTION_ID_OFFSET) {
        /* We shouldn't ever get an ECALL generated by sgx_edger8r */
        assert(FALSE);
    } else {
        type = type - V2_FUNCTION_ID_OFFSET;

        if (type >= g_ocall_table_v2.nr_ocall)
            return TEEC_ERROR_BAD_PARAMETERS;

        uint32_t bytes_written = 0;
        g_ocall_table_v2.call_addr[type](
            input_buffer,
            input_buffer_size,
            output_buffer,
            output_buffer_size,
            &bytes_written);
        
        result = OE_OK;
    }

    return result == OE_OK ? TEEC_SUCCESS : TEEC_ERROR_GENERIC;
}

static void *generic_rpc_thread_procedure(void *param)
{
    TEEC_Result res;

    struct tcps_optee_context *optee;

    optee = (struct tcps_optee_context *)param;
    res = TEEC_ReceiveReplyGenericRpc(&optee->session, handle_generic_rpc, optee);

    return (void *)(uintptr_t)res;
}

static oe_result_t uuid_from_string(
    char *a_TaIdString,
    TEEC_UUID *a_Uuid)
{
    int i;
    uint64_t uuid_parts[5];
    char *id_copy;
    const char *current_token;

    if (strlen(a_TaIdString) != 36)
        return OE_INVALID_PARAMETER;

    id_copy = strdup(a_TaIdString);

    i = 5;
    current_token = strtok((char *)id_copy, "-");
    while (current_token != NULL && i >= 0) {
        uuid_parts[--i] = strtoull(current_token, NULL, 16);
        current_token = strtok(NULL, "-");
    }

    free(id_copy);

    if (i != 0)
        return OE_INVALID_PARAMETER;

    a_Uuid->timeLow            = (uint32_t)uuid_parts[4];
    a_Uuid->timeMid            = (uint16_t)uuid_parts[3];
    a_Uuid->timeHiAndVersion   = (uint16_t)uuid_parts[2];
    a_Uuid->clockSeqAndNode[0] = (uint8_t)(uuid_parts[1] >> (8 * 1));
    a_Uuid->clockSeqAndNode[1] = (uint8_t)(uuid_parts[1] >> (8 * 0));
    a_Uuid->clockSeqAndNode[2] = (uint8_t)(uuid_parts[0] >> (8 * 5));
    a_Uuid->clockSeqAndNode[3] = (uint8_t)(uuid_parts[0] >> (8 * 4));
    a_Uuid->clockSeqAndNode[4] = (uint8_t)(uuid_parts[0] >> (8 * 3));
    a_Uuid->clockSeqAndNode[5] = (uint8_t)(uuid_parts[0] >> (8 * 2));
    a_Uuid->clockSeqAndNode[6] = (uint8_t)(uuid_parts[0] >> (8 * 1));
    a_Uuid->clockSeqAndNode[7] = (uint8_t)(uuid_parts[0] >> (8 * 0));

    return OE_OK;
}

oe_result_t oe_create_enclave_helper(
    _In_z_ const char* a_TaIdString,
    uint32_t a_Flags,
    _Out_ oe_enclave_t** a_pId)
{
    oe_result_t status;
    
    TEEC_Result res;
    TEEC_UUID uuid;
    struct tcps_optee_context *optee;
    uint32_t err_origin;
    int s;

    char uuidstring[80];
    strcpy_s(uuidstring, sizeof(uuidstring), a_TaIdString);

    /* Remove ".ta" extension, if one is present. */
    size_t len = strlen(uuidstring);
    if ((len > 3) && (strcmp(&uuidstring[len - 3], ".ta") == 0)) {
        uuidstring[len - 3] = 0;
    }
   
    OE_UNUSED(a_Flags);

    status = uuid_from_string((char *)a_TaIdString, &uuid);
    if (status != OE_OK) {
        return status;
    }

    optee = malloc(sizeof(*optee));
    if (!optee) {
        return OE_OUT_OF_MEMORY;
    }

    s = pthread_mutex_init(&optee->mutex, NULL);
    if (s) {
        status = OE_FAILURE;
        goto out_optee_alloc;
    }

    res = TEEC_InitializeContext(NULL, &optee->ctx);
    if (res != TEEC_SUCCESS) {
        status = OE_FAILURE;
        goto out_mutex;
    }

    res = TEEC_OpenSession(&optee->ctx, &optee->session, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &err_origin);
    if (res != TEEC_SUCCESS) {
        status = OE_FAILURE;
        goto out_ctx;
    }

    s = pthread_create(&optee->rpc_thread, NULL, generic_rpc_thread_procedure, optee);
    if (s) {
        status = OE_FAILURE;
        goto out_sess;
    }

    *a_pId = (oe_enclave_t*)optee;

    return OE_OK;

out_sess:
    TEEC_CloseSession(&optee->session);
out_ctx:
    TEEC_FinalizeContext(&optee->ctx);
out_mutex:
    pthread_mutex_destroy(&optee->mutex);
out_optee_alloc:
    free(optee);
 
    return status;
}

oe_result_t oe_terminate_enclave(
    _In_ oe_enclave_t *enclave)
{
    struct tcps_optee_context *optee;
 
    if (!enclave)
        return OE_INVALID_PARAMETER;

    optee = (struct tpcs_optee_context *)enclave;

    TEEC_CloseSession(&optee->session);
    TEEC_FinalizeContext(&optee->ctx);
    pthread_mutex_destroy(&optee->mutex);
    free(optee);

    return OE_OK;
}
