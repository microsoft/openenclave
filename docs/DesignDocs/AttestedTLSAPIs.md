Attested TLS APIs
==========================

Motivation
------------

An important use case for an enclave is establishing an attested
TLS channel. The attested TLS channel allows a remote party
to authenticate the enclave identity during a TLS handshake,
which bridges the data-in-use and data-in-transit protection.
The Open Enclave SDK demonstrates this use case in the
[attested TLS samples](/samples/attested_tls) with the use of two
APIs, `oe_get_attestation_certificate_with_evidence_v2` and
`oe_verify_attestation_certificate_with_evidence_v2`.
The `oe_get_attestation_certificate_with_evidence_v2` API allows
a developer to obtain a self-signed certificate with the enclave
evidence embedded, which then is used during the TLS handshake.
More importantly, the API binds the public key of the certificate
with evidence such that the TLS channel based on the public key
can be *attested*. To validate the certificate, the receiver uses the
`oe_verify_attestation_certificate_with_evidence_v2` API, which
assesses the trustworthiness of the evidence (e.g., based on the DCAP client for SGX).
In addition, the API outputs a list of claims, allowing the developer
to implement additional verification logic (e.g., authenticate the
enclave identity such as `MRENCLAVE` in SGX). After successful
validation, the receiver continues the handshake and finally establishes
an *attested* secure channel with the sender.

While the two APIs are useful in the above end-to-end scenario,
they have the following limitations:

- Do not support general use cases

  A typical attestation procedure includes three roles: an attester, a relying party,
  and a verifier. Two general models are as follows
  (refer to [Remote Attestation Procedures Architecture](https://datatracker.ietf.org/doc/html/draft-ietf-rats-architecture)
   to more detail).
  - Passport Model

    The attester generates evidence and asks the verifier to assess the
    trustworthiness of the evidence. Then, the attester sends the attestation result
    to the relying party. Finally, the relying party validates the attestation result
    based on customized policies.

  - Background-Check Model

    The attester generates the evidence and directly sends the evidence to the
    relying party. The relying party then asks a verifier to assess the trustworthiness
    of the evidence and then validates the attestation result based on customized policies.

  The APIs, however, only support the special case of the background-check model where
  the sender of the certificate is the attester and the receiver of the certificate plays
  the roles of both the verifier and the relying party. More specifically, the
  `oe_get_attestation_certificate_with_evidence_v2` API internally obtains
  the raw enclave evidence and embeds it into the output certificate while the
  `oe_verify_attestation_certificate_with_evidence_v2` API takes the certificate
  as input, extracts and verifies the evidence internally based on the local DCAP
  client, and outputs the list of the claims. As a result, neither can the sender
  embed the attestation result into the certificate (passport model) nor can the receiver extract
  the raw evidence from the certificate and ask the verifier to assess the evidence
  (background-check model).

- Lack of support of init-time custom claims

  According to [Open Enclave Init-time Configuration Interface](InitTimeConfigurationInterface.md),
  the support of init-time custom claims is desirable when the TEE hardware has such
  support (e.g., `CONFIGID` in SGX2). The `oe_get_attestation_certificate_with_evidence_v2`
  API does not allow developers to provide an init-time custom claim buffer as input.

- Limited support for run-time custom claims

  The notion of run-time custom claims is equivalent to the custom claims
  in the OE attestation plugin framework. The APIs enforce the binding between the public key
  of the self-signed certificate and the enclave evidence by assuming the run-time custom
  claims include only the public key. This contract prevents the flexible use
  of the run-time custom claims (i.e., including data in addition to the public key).

Specification
--------

This document proposes the following new APIs that address the above-mentioned limitations.
- `oe_get_passport_attestation_certificate_v1`
- `oe_get_background_check_attestation_certificate_v1`
- `oe_parse_passport_attestation_certificate_v1`
- `oe_parse_background_check_attestation_certificate_v1`

Note that these APIs are designed to support the end-to-end scenario between the
attester and the relying party. Therefore, the certificate generated by
`oe_get_passport_attestation_certificate` and
`oe_get_background_check_attestation_certificate`
does not provide backward compatibility to existing verification APIs
(e.g., `oe_verify_attestation_certificate_with_evidence_v2`
and `oe_verify_attestation_certificate`) that should be used by verifiers.
Also, the operations between one party and the verifier (e.g., getting the attestation
result and parsing the attestation result) are out-of-scope in the proposed APIs.
However, these operations are required to establish the fully end-to-end attested
TLS between the attester and the relying party in addition to using the proposed
APIs (see [User Experience](#user-experience) for more detail).

- oe_get_passport_attestation_certificate_v1
  ```c
  /**
   * oe_get_passport_attestation_certificate_v1
   *
   * This function generates a self-signed X.509 certificate in DER format with embedded attestation result
   * returned by a verifier. Note that the attestation result is an opaque buffer. The rule
   * to interpret the buffer depends on the agreement between the relying party and the verifier.
   *
   * @experimental
   *
   * @param[in] subject_name A string containing an X.509 distinguished
   * name (DN) for customizing the generated certificate. This name is also used
   * as the issuer name because this is a self-signed certificate.
   * See RFC5280 (https://tools.ietf.org/html/rfc5280) for details.
   * Example value "CN=Open Enclave SDK,O=OESDK TLS,C=US"
   * @param[in] private_key A private key used to sign this certificate.
   * @param[in] private_key_size The size of the buffer above.
   * @param[in] public_key A public key used as the certificate's subject key.
   * @param[in] public_key_size The size of the buffer above.
   * @param[in] attestation_result_buffer An optional flat buffer representing the attestation
   * results from a verifier.
   * @param[in] attestation_result_buffer_size The size of the buffer above in bytes.
   * @param[in] optional_parameters The optional format-specific input parameters.
   * @param[in] optional_parameters_size The size of buffer above in bytes.
   * @param[out] output_certificate_in_der A pointer to buffer pointer.
   * @param[out] output_certificate_size The pointer to the size of the buffer above.
   *
   * @retval OE_OK The operation was successful.
   * @retval OE_INVALID_PARAMETER One or more invalid parameters.
   * @retval Other appropriate error code.
   */
  oe_result_t oe_get_passport_attestation_certificate_v1(
      const unsigned char* subject_name,
      const uint8_t* private_key,
      size_t private_key_size,
      const uint8_t* public_key,
      size_t public_key_size,
      const uint8_t* attestation_result_buffer,
      size_t attestation_result_buffer_size,
      uint8_t** output_certificate_in_der,
      size_t* output_certificate_in_der_size);
  ```
  The API generates a certificate with an embedded attestation result that is specifically used
  by an attested TLS with the passport model.
  An important note is that the API treats the input attestation result as an opaque blob and does
  not enforce the binding between the public key and the attestation result. The attester and the
  relying party are responsible for enforcing and verifying the binding outside of this API, based
  on the agreement of a specific format for the attestation result (e.g., MAA format).

- oe_get_background_check_attestation_certificate_v1
  ```c
  /**
   * oe_get_background_check_attestation_certificate_v1
   *
   * This function generates a self-signed X.509 certificate in DER format with embedded evidence generated
   * by an attester plugin for the enclave. In addition, it allows an application to optionally
   * pass in run-time custom claims and init-time custom claims.
   *
   * @experimental
   *
   * @param[in] format_id The format id of the evidence to be generated.
   * Supported: OE_FORMAT_UUID_SGX_ECDSA and OE_FORMAT_UUID_SGX_LOCAL_ATTESTATION.
   * @param[in] subject_name A string containing an X.509 distinguished
   * name (DN) for customizing the generated certificate. This name is also used
   * as the issuer name because this is a self-signed certificate.
   * See RFC5280 (https://tools.ietf.org/html/rfc5280) for details.
   * Example value "CN=Open Enclave SDK,O=OESDK TLS,C=US"
   * @param[in] private_key A private key used to sign this certificate.
   * @param[in] private_key_size The size of the buffer above.
   * @param[in] public_key A public key used as the certificate's subject key.
   * @param[in] public_key_size The size of the buffer above.
   * @param[in] inittime_custom_claims_buffer An optional flat buffer representing the init-time
   * custom claims.
   * @param[in] inittime_custom_claims_buffer_size The size of the buffer above in bytes.
   * @param[in] runtime_custom_claims_buffer An optional flat buffer representing the run-time
   * cutom claims.
   * @param[in] runtime_custom_claims_buffer_size The size of the buffer above in bytes.
   * @param[in] optional_parameters The optional format-specific input parameters.
   * @param[in] optional_parameters_size The size of buffer above in bytes.
   * @param[out] output_certificate_in_der A pointer to buffer pointer.
   * @param[out] output_certificate_in_der_size The pointer to the size of the buffer above.
   *
   * @retval OE_OK The operation was successful.
   */
  oe_result_t oe_get_background_check_attestation_certificate_v1(
      const oe_uuid_t* format_id,
      const unsigned char* subject_name,
      const uint8_t* private_key,
      size_t private_key_size,
      const uint8_t* public_key,
      size_t public_key_size,
      const uint8_t* runtime_custom_claims_buffer,
      size_t runtime_custom_claims_buffer_size,
      const uint8_t* inittime_custom_claims_buffer,
      size_t inittime_custom_claims_buffer_size,
      const void* optional_parameters,
      size_t optional_parameters_size,
      uint8_t** output_certificate_in_der,
      size_t* output_certificate_in_der_size);
  ```

  The API extends the `oe_get_attestation_certificate_with_evidence_v2` API to support attested
  TLS with the general background-check model. The API introduces the following four arguments that allow
  developers to optionally pass in run-time and init-time custom claims.
  - `runtime_custom_claims_buffer`
  - `runtime_custom_claims_buffer_size`
  - `inittime_custom_claims_buffer`
  - `inittime_custom_claims_buffer_size`

  Note that the API assumes `runtime_custom_claims_buffer` and `inittime_custom_claims_buffer`
  are opaque buffers whose format is application-specific, depending on the agreement between parties involved
  in the attestation procedure. However, to maintain the binding between the public key and the
  evidence, the caller of the API is responsible to include the public key into the `runtime_custom_claims_buffer`.
  Also, the relying party should agree on the format with the attester to extract the public key from
  the `runtime_custom_claims_buffer`. Note that, to provide backward compatibility with
  existing `oe_verify_attestation_certificate_with_evidence_v2` API, the caller of the API needs to ensure
  that the `runtime_custom_claims_buffer` includes exactly the public key.
  
- oe_parse_passport_attestation_certificate_v1
  ```c
  /**
   * oe_parse_passport_attestation_certificate_v1
   *
   * This function parses the certificate generated by
   * oe_get_passport_attestation_certificate_v1 and outputs
   * the attestation result.
   *
   * @experimental
   *
   * @param[in] certificate_in_der A pointer to buffer holding certificate
   * contents in DER format.
   * @param[in] certificate_in_der_size The size of the buffer above.
   * @param[out] output_attestation_result_buffer A pointer to buffer pointer.
   * @param[out] output_attestation_result_buffer_size A pointer to the size of
   * the buffer above.
   * @retval OE_OK Successful parsing.
   * @retval OE_INVALID_PARAMETER One or more invalid parameters.
   * @retval Other appropriate error code.
   */
  oe_result_t oe_parse_passport_attestation_certificate_v1(
      const uint8_t* certificate_in_der,
      size_t certificate_in_der_size,
      uint8_t** output_attestation_result_buffer,
      size_t* uint8_t output_attestation_result_buffer_size);
  ```
  The API is used to parse the certificate generated by `oe_get_passport_attestation_certificate_v1`.
  An alternative design is representing
  the output buffers as a list of claims (reducing the number of arguments). However, given that the
  design does not provide APIs to interpret these buffers, therefore, the decision is not introducing
  pre-defined claims types for them.

- oe_parse_background_check_attestation_certificate_v1
  ```c
  /**
   * oe_parse_background_check_attestation_certificate_v1
   *
   * This function parses the certificate generated by
   * oe_get_background_check_attestation_certificate_v1
   * and outputs the evidence and optionally init-time custom
   * claims and run-time custom claims.
   *
   * @experimental
   *
   * @param[in] certificate_in_der A pointer to buffer holding certificate
   * contents in DER format.
   * @param[in] certificate_in_der_size The size of the buffer above.
   * @param[out] output_evidence_buffer A pointer to buffer pointer.
   * @param[out] output_evidence_buffer_size The size of the buffer above.
   * @param[out] output_inittime_custom_claims_buffer An optional pointer to buffer pointer.
   * @param[out] output_inittime_custom_claims_buffer_size An optional pointer to the size of
   * the buffer above.
   * @param[out] output_runtime_custom_claims_buffer An optional pointer to buffer pointer.
   * @param[out] output_runtime_custom_claims_buffer_size An optional pointer to the size of
   * the buffer above.
   * @retval OE_OK Successful parsing.
   * @retval OE_INVALID_PARAMETER One or more invalid parameters.
   * @retval Other appropriate error code.
   */
  oe_result_t oe_parse_background_check_attestation_certificate_v1(
      const uint8_t* certificate_in_der,
      size_t certificate_in_der_size,
      uint8_t** output_evidence_buffer,
      size_t* output_evidence_buffer_size,
      uint8_t** output_inittime_custom_claims_buffer,
      size_t* output_inittime_custom_claims_buffer_size,
      uint8_t** output_runtime_custom_claims_buffer,
      size_t* output_runtime_custom_claims_buffer_size);
  ```
  Similar to the `oe_parse_passport_attestation_certificate_v1`, the API is used to parse the
  certificate generated by `oe_get_background_check_attestation_certificate_v1`.

User Experience
--------

The following examples demonstrate the use of proposed APIs.

- Passport Model

  ```c
  // The attester is responsible for validating the init-time custom
  // claims prior to the attestation procedure.
  static const uint8_t inittime_custom_claims[] =
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
  ...

  // Attester
  uint8_t* runtime_custom_claims_buffer = NULL;
  size_t runtime_custom_claims_buffer_size = 0;
  uint8_t* evidence_buffer = NULL;
  size_t evidence_buffer_size = 0;
  uint8_t* attestation_result_buffer = NULL;
  size_t attestation_result_buffer_size = 0;

  // An example of enforcing the binding between the public
  // key of the certificate and the evidence.
  runtime_custom_claims_buffer = public_key;
  runtime_custom_claims_buffer_size = public_key_size;

  result = oe_get_evidence(
      format_id,
      OE_EVIDENCE_FLAGS_EMBED_FORMAT_ID,
      runtime_custom_claims_buffer,
      runtime_custom_claims_buffer_size,
      optional_parameters,
      optional_parameters_size,
      &evidence_buffer,
      &evidence_buffer_size,
      NULL,
      0);
  OE_CHECK_MSG(
      result, "oe_get_evidence failed with %s\n", oe_result_str(result));

  // Send the evidence_buffer, init-time custom claims, and run-time custom claims
  // to the verifier. Note that the evidence_buffer already includes the run-time
  // custom claims. The result is saved in the attestation_result_buffer.
  // An example is using MAA's REST API. Refer to
  // https://docs.microsoft.com/en-us/rest/api/attestation/attestation/attest-open-enclave
  // for more detail.

  ...

  uint8_t* output_certificate = NULL;
  size_t output_certificate_size = 0;

  result = oe_get_passport_attestation_certificate_v1(
       (const unsigned char*)"CN=Open Enclave SDK,O=OESDK TLS,C=US",
       private_key,
       private_key_size,
       public_key,
       public_key_size,
       attestation_result_buffer,
       attestation_result_buffer_size,
       &output_certificate,
       &output_certificate_size);
  OE_CHECK(result);


  // Send output_certificate to the relying party during the TLS handshake
  // See the attested TLS sample for more detail.

  ...

  // Relying party (receive input_certificate) during the certificate
  // verification callback (see the attested TLS sample for more detail).
  uint8_t* attestation_result_buffer;
  size_t attestation_result_buffer_size;

  result = oe_parse_passport_attestation_certificate_v1(
       input_certificate,
       input_certificate_size,
       &attestation_result_buffer,
       &attestation_result_buffer_size);
  OE_CHECK(result);
  
  // Verify the attestation result and check the public key against the
  // attestation result (e.g., an MAA token). Such logic is application-specific.
  //
  // Example of parsing the attestation result:
  //    claims_t* claims = NULL;
  //    size_t claims_length = 0;
  //
  //    /* Validate the attestation result and output a list of claims */
  //    parse_attestation_result(
  //        attestation_result_buffer,
  //        attestation_result_buffer_size,
  //        &claims,
  //        &claims_length);
  //
  //    /* Iterate through the output claims and perform checks based on policies */
  //    for (size_t i = 0; i < claims_length; i++)
  //    {
  //         claim_t* claim = &claims[i];
  //         ...
  //    }
  ...

  ```

- Background-Check Model

  ```c
  // The attester is responsible for validating the init-time custom
  // claims prior to the attestation procedure.
  static const uint8_t inittime_custom_claims[] =
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
  ...

  // Attester
  oe_uuid_t format_id = (oe_uuid_t)OE_FORMAT_UUID_SGX_ECDSA;
  uint8_t* runtime_custom_claims_buffer = NULL;
  uint8_t* runtime_custom_claims_buffer_size = 0;
  uint8_t* output_certificate = NULL;
  size_t output_certificate_size = 0;

  // An example of enforcing the binding between the public
  // key of the certificate and the evidence.
  runtime_custom_claims_buffer = public_key;
  runtime_custom_claims_buffer_size = public_key_size;
  
  
  ...

  result = oe_get_background_check_attestation_certificate_v1(
       &format_id,
       (const unsigned char*)"CN=Open Enclave SDK,O=OESDK TLS,C=US",
       private_key,
       private_key_size,
       public_key,
       public_key_size,
       runtime_custom_claims_buffer,
       runtime_custom_claims_buffer_size,
       inittime_custom_claims,
       sizeof(inittime_custom_claims),
       NULL,
       0,
       &output_certificate,
       &output_certificate_size);
  OE_CHECK(result);

  ...

  // Send output_certificate to the relying party during the TLS handshake
  // See the attested TLS sample for more detail.

  ...

  // Relying party (receive input_certificate) during the certificate
  // verification callback (see the attested TLS sample for more detail).
  uint8_t* evidence_buffer;
  size_t evidence_buffer_size;
  uint8_t* inittime_custom_claims_buffer;
  size_t inittime_custom_claims_buffer_size;
  uint8_t* runtime_custom_claims_buffer;
  size_t runtime_custom_claims_buffer_size;

  result = oe_parse_background_check_attestation_certificate_v1(
       input_certificate,
       input_certificate_size,
       &evidence_buffer,
       &evidence_buffer_size,
       &inittime_custom_claims_buffer,
       &inittime_custom_claims_buffer_size,
       &runtime_custom_claims_buffer,
       &runtime_custom_claims_buffer_size);
  OE_CHECK(result);

  // Option 1
  // Send the evidence, init-time custom claims, and run-time claims to the verifier.
  // Next, verify the attestation result and check the public key against the
  // attestation result (e.g., an MAA token). Such logic is application-specific.

  // Option 2
  // Validate the public key against the evidence and proceed with the handshake.
  // After establishing the secure channel, talk to verifier to perform the validation
  // against the attestation result.

  // Example of parsing attestation result:
  //    claims_t* claims = NULL;
  //    size_t claims_length = 0;
  //
  //    /* Validate the attestation result and output a list of claims */
  //    parse_attestation_result(
  //        attestation_result_buffer,
  //        attestation_result_buffer_size,
  //        &claims,
  //        &claims_length);
  //
  //    /* Iterate through the output claims and perform checks based on policies */
  //    for (size_t i = 0; i < claims_length; i++)
  //    {
  //         claim_t* claim = &claims[i];
  //         ...
  //    }
  ```

Design
--------

- oe_get_passport_attestation_certificate_v1

  A design for this API is introducing a new OID for
  the attestation result. Such design requires
  modifications to the internal `generate_x509_self_signed_certificate` API as shown below.

  ```diff
  oe_result_t oe_get_passport_attestation_certificate_v1(
      const unsigned char* subject_name,
      const uint8_t* private_key,
      size_t private_key_size,
      const uint8_t* public_key,
      size_t public_key_size,
  +   const uint8_t* attestation_result_buffer,
  +   size_t attestation_result_buffer_size,
      uint8_t** output_certificate_in_der,
      size_t* output_certificate_size)
  {
      oe_result_t result = OE_FAILURE;
  +   uint8_t* certificate_in_der = NULL;
  +   size_t certificate_size = 0;

      OE_TRACE_VERBOSE("Calling oe_get_passport_attestation_certificate");

  +   if (!private_key || !private_key_size || !public_key || !public_key_size ||
  +       !attestation_result_buffer || !attestation_result_buffer_size ||
  +       !output_certificate_in_der || !output_certificate_size)
  +       OE_RAISE(OE_INVALID_PARAMETER);

  +   *output_certificate_in_der = NULL;
  +   *output_certificate_size = 0;

      result = generate_x509_self_signed_certificate(
          oid_oe_evidence,
          sizeof(oid_oe_evidence),
          subject_name,
          private_key,
          private_key_size,
          public_key,
          public_key_size,
  -       evidence_buffer,
  -       evidence_buffer_size,
  +       attestation_result_buffer,
  +       attestation_result_buffer_size,
          output_certificate_in_der,
          output_certificate_size);
      OE_CHECK_MSG(
          result,
          "generate_x509_self_signed_certificate failed : %s",
          oe_result_str(result));

      OE_TRACE_VERBOSE(
          "self-signed certificate size = %d", *output_certificate_size);

  +   *output_certificate_in_der = certificate_in_der;
  +   *output_certificate_size = certificate_size;

      result = OE_OK;

  done:
      oe_free_evidence(evidence_buffer);
      return result;
  }
  ```

- oe_get_background_check_attestation_certificate_v1

  The support of init-time custom claims is based on the design outlined in
  [Open Enclave Init-time Configuration Interface](InitTimeConfigurationInterface.md):
  appending the init-time custom claims to the evidence buffer and then embedding the
  new evidence buffer into the certificate. For the support of run-time custom claims,
  the API directly feeds the input to the `oe_get_evidence` API, which previously takes
  the `public_key` buffer as input.

  Note that, as mentioned in the [Specification](#specification) section, the certificate
  generated by this API does not provide backward compatibility
  to existing `oe_verify_attestation_certificate_with_evidence_v2` API; i.e.,
  the existing verification API is unable to interpret the evidence buffer with init-time
  custom claims appended and the run-time custom claim that includes data other than
  the `public_key`.

  ```diff
  oe_result_t oe_get_background_check_attestation_certificate_v1(
      const oe_uuid_t* format_id,
      const unsigned char* subject_name,
      const uint8_t* private_key,
      size_t private_key_size,
      const uint8_t* public_key,
      size_t public_key_size,
  +   const uint8_t* runtime_custom_claims_buffer,
  +   size_t runtime_custom_claims_buffer_size,
  +   const uint8_t* inittime_custom_claims_buffer,
  +   size_t inittime_custom_claims_buffer_size,
      const void* optional_parameters,
      size_t optional_parameters_size,
      uint8_t** output_certificate,
      size_t* output_certificate_size)
  {
      oe_result_t result = OE_FAILURE;
      uint8_t* evidence_buffer = NULL;
      size_t evidence_buffer_size = 0;
      uint8_t* certificate_in_der = NULL;
      size_t certificate_in_der_size = 0;

      OE_TRACE_VERBOSE("Calling oe_get_background_check_attestation_certificate");

      if (!format_id || !private_key || !private_key_size || !public_key ||
          !public_key_size || !output_certificate_in_der ||
          !output_certificate_size)
          OE_RAISE(OE_INVALID_PARAMETER);

      *output_certificate_in_der = NULL;
      *output_certificate_size = 0;

      // Do not support legacy format and raw quote
      if (memcmp(format_id, &_uuid_sgx_local_attestation, sizeof(oe_uuid_t)) &&
          memcmp(format_id, &_uuid_sgx_ecdsa, sizeof(oe_uuid_t)))
          OE_RAISE(OE_UNSUPPORTED);

      result = oe_get_evidence(
          format_id,
          OE_EVIDENCE_FLAGS_EMBED_FORMAT_ID,
  -       public_key,
  -       public_key_size,
  +       runtime_custom_claims_buffer,
  +       runtime_custom_claims_buffer_size,
          optional_parameters,
          optional_parameters_size,
          &evidence_buffer,
          &evidence_buffer_size,
          NULL,
          0);
      OE_CHECK_MSG(
          result, "oe_get_evidence failed with %s\n", oe_result_str(result));

  +   if (inittime_custom_claims_buffer && inittime_custom_claims_buffer_size)
  +   {
  +       size_t evidence_with_inittime_claims_size;
  +       OE_CHECK(oe_safe_add_sizet(
  +           evidence_buffer_size,
  +           inittime_custom_claims_buffer_size,
  +           &evidence_with_inittime_claims_size));
  +       evidence_buffer =
  +           oe_realloc(evidence_buffer, evidence_with_inittime_claims_size);
  +       if (!evidence_buffer)
  +           OE_RAISE(OE_OUT_OF_MEMORY);
  +       uint64_t inittime_custom_claims_offset;
  +       OE_CHECK(oe_safe_add_u64(
  +           (uint64_t)evidence_buffer,
  +           (uint64_t)evidence_buffer_size,
  +           &inittime_custom_claims_offset));
  +       OE_CHECK(oe_memcpy_s(
  +           (void*)inittime_custom_claims_offset,
  +           inittime_custom_claims_buffer_size,
  +           inittime_custom_claims_buffer,
  +           inittime_custom_claims_buffer_size));
  +       evidence_buffer_size = evidence_with_inittime_claims_size;
  +   }

      result = generate_x509_self_signed_certificate(
          oid_oe_evidence,
          sizeof(oid_oe_evidence),
          subject_name,
          private_key,
          private_key_size,
          public_key,
          public_key_size,
          evidence_buffer,
          evidence_buffer_size,
          output_certificate,
          output_certificate_size);
      OE_CHECK_MSG(
          result,
          "generate_x509_self_signed_certificate failed : %s",
          oe_result_str(result));

      OE_TRACE_VERBOSE(
          "self-signed certificate size = %d", *output_certificate_size);

  +   *output_certificate_in_der = certificate_in_der;
  +   *output_certificate_in_der_size = certificate_in_der_size;

      result = OE_OK;

  done:
      oe_free(evidence_buffer);

      return result;
  }
  ```

- oe_parse_passport_attestation_certificate_v1

  ```c
  oe_result_t oe_parse_attestation_certificate_v1(
      const uint8_t* certificate_in_der,
      size_t certificate_in_der_size,
      uint8_t** output_attestation_result_buffer,
      size_t* output_attestation_result_buffer_size)
  {
      oe_result_t result = OE_FAILURE;
      oe_cert_t certificate = {0};
      uint8_t* attestation_result_buffer = NULL;
      size_t attestation_result_buffer_size = 0;

      if (!certificate_in_der || !certificate_in_der_size ||
          !output_attestation_result_buffer ||
          !output_attestation_result_buffer_size)
          OE_RAISE(OE_INVALID_PARAMETER);

      *output_attestation_result_buffer = NULL;
      *output_attestation_result_buffer_size = 0;

      result =
          oe_cert_read_der(&certificate, certificate_in_der, certificate_in_der_size);
      OE_CHECK_MSG(result, "certificate_in_der_size=%d", certificate_in_der_size);

      // validate the certificate signature
      result = oe_cert_verify(&certificate, NULL, NULL, 0);
      OE_CHECK_MSG(
          result,
          "oe_cert_verify failed with error = %s\n",
          oe_result_str(result));

      result = oe_cert_find_extension(
          &certificate,
          (const char*)oid_oe_attestation_result,
          &attestation_result_buffer,
          &attestation_result_buffer_size);
      OE_CHECK_MSG(
          result,
          "oe_cert_find_extension failed with error = %s\n",
          oe_result_str(result));

      *output_attestation_result_buffer = attestation_result_buffer;
      *output_attestation_result_buffer_size = attestation_result_buffer_size;

      result = OE_OK;

  done:
      oe_cert_free(&certificate);
      return results;
  }
  ```

- oe_parse_background_check_attestation_certificate_v1

  The function extracts the evidence (including init-time custom claims)
  from the certificate and then uses an newly introduced internal API, `oe_parse_evidence_with_inittime_claims`
  to extract the evidence (without init-time custom claims), init-time custom claims, and run-time custom claims from the
  evidence. The implementation of `oe_parse_evidence_with_inittime_claims` is TEE-dependent.

  ```c
  oe_result_t oe_parse_background_check_attestation_certificate_v1(
      const uint8_t* certificate_in_der,
      size_t certificate_in_der_size,
      uint8_t** output_evidence_buffer,
      size_t* output_evidence_buffer_size,
      uint8_t** output_inittime_custom_claims_buffer,
      size_t* output_inittime_custom_claims_buffer_size,
      uint8_t** output_runtime_custom_claims_buffer,
      size_t* output_runtime_custom_claims_buffer_size)
  {
      oe_result_t result = OE_FAILURE;
      oe_cert_t certificate = {0};
      uint8_t* evidence_with_inittime_claims = NULL;
      size_t evidence_with_inittime_claims_size = 0;

      if (!certificate_in_der_size || !certificate_in_der_size ||
          OE_RAISE(OE_INVALID_PARAMETER);

      result = oe_cert_read_der(
          &certificate, certificate_in_der, certificate_in_der_size);
      OE_CHECK_MSG(result, "certificate_in_der_size=%d", certificate_in_der_size);

      // Validate the certificate signature
      result = oe_cert_verify(&certificate, NULL, NULL, 0);
      OE_CHECK_MSG(
          result,
          "oe_cert_verify failed with error = %s\n",
          oe_result_str(result));

      result = oe_cert_find_extension(
          &certificate,
          (const char*)oid_oe_evidence,
          &evidence_with_inittime_claims,
          &evidence_with_inittime_claims_size);
      OE_CHECK_MSG(
          result,
          "oe_cert_find_extension failed with error = %s\n",
          oe_result_str(result));

      OE_CHECK(oe_parse_evidence_with_inittime_claims(
          evidence_with_inittime_claims,
          evidence_with_inittime_claims_size,
          output_evidence_buffer,
          output_evidence_buffer_size,
          output_inittime_custom_claims_buffer,
          output_inittime_custom_claims_buffer_size,
          output_runtime_custom_claims_buffer,
          output_runtime_custom_claims_buffer_size));

      result = OE_OK;

  done:
      oe_cert_free(&certificate);
      return result;
  }
  ```

  An implementation of `oe_parse_evidence_with_inittime_claims` for SGX is as follows.
  ```c
  static const oe_uuid_t _uuid_sgx_local_attestation = {
    OE_FORMAT_UUID_SGX_LOCAL_ATTESTATION};
  static const oe_uuid_t _uuid_sgx_ecdsa = {OE_FORMAT_UUID_SGX_ECDSA};

  oe_result_t oe_parse_evidence_with_inittime_claims(
      uint8_t* evidence_with_inittime_claims,
      size_t evidence_with_inittime_claims_size,
      uint8_t** output_evidence_buffer,
      size_t* output_evidence_buffer_size,
      uint8_t** output_inittime_custom_claims_buffer,
      size_t* output_inittime_custom_claims_buffer_size,
      uint8_t** output_runtime_custom_claims_buffer,
      size_t* output_runtime_custom_claims_buffer_size)
  {
      oe_result_t result = OE_FAILURE;
      uint8_t* evidence = NULL;
      size_t evidence_size = 0;
      bool has_input_inittime_claims = false;
      uint8_t* inittime_claims = NULL;
      size_t inittime_claims_size = 0;
      bool has_input_runtime_claims = false;
      uint8_t* runtime_claims = NULL;
      size_t runtime_claims_size = 0;
      oe_attestation_header_t* header = NULL;
      oe_uuid_t* format_id = NULL;
      uint8_t* report = NULL;
      size_t report_size = 0;

      if (!evidence_with_inittime_claims || !evidence_with_inittime_claims_size ||
          !output_evidence_buffer || !output_evidence_buffer_size)
          OE_RAISE(OE_INVALID_PARAMETER);

      *output_evidence_buffer = NULL;
      *output_evidence_buffer_size = 0;

      if (output_inittime_custom_claims_buffer &&
          output_inittime_custom_claims_buffer_size)
      {
          *output_inittime_custom_claims_buffer = NULL;
          *output_inittime_custom_claims_buffer_size = 0;
          has_input_inittime_claims = true;
      }

      if (output_runtime_custom_claims_buffer &&
          output_runtime_custom_claims_buffer_size)
      {
          *output_runtime_custom_claims_buffer = NULL;
          *output_runtime_custom_claims_buffer_size = 0;
          has_input_runtime_claims = true;
      }

      // Find the header version
      header = (oe_attestation_header_t*)evidence_with_inittime_claims;
      if (header->version != OE_ATTESTATION_HEADER_VERSION)
          OE_RAISE_MSG(
              OE_INVALID_PARAMETER,
              "Invalid attestation header version %d, expected %d",
              header->version,
              OE_ATTESTATION_HEADER_VERSION);

      OE_CHECK(oe_safe_add_sizet(
          sizeof(oe_attestation_header_t), header->data_size, &evidence_size));

      // Extract inittime custom claims
      if (has_input_inittime_claims && (evidence_with_inittime_claims_size > evidence_size))
      {
          uint64_t inittime_claims_offset;
          OE_CHECK(oe_safe_sub_sizet(
              evidence_with_inittime_claims_size, evidence_size, &inittime_claims_size));
          inittime_claims = (uint8_t*)oe_malloc(inittime_claims_size);
          if (!inittime_claims)
              OE_RAISE(OE_OUT_OF_MEMORY);
          OE_CHECK(oe_safe_add_u64(
              (uint64_t)evidence_with_inittime_claims,
              (uint64_t)evidence_size,
              &inittime_claims_offset));
          OE_CHECK(oe_memcpy_s(
              inittime_claims,
              inittime_claims_size,
              (void*)inittime_claims_offset,
              inittime_claims_size));
      }

      // Unwrap the report from evidence
      report = (uint8_t*)header->data;
      format_id = &header->format_id;
      if (!memcmp(format_id, &_uuid_sgx_local_attestation, sizeof(oe_uuid_t)))
          report_size = sizeof(sgx_report_t);
      else if (!memcmp(format_id, &_uuid_sgx_ecdsa, sizeof(oe_uuid_t)))
          OE_CHECK(oe_safe_add_sizet(
              ((sgx_quote_t*)report)->signature_len,
              sizeof(sgx_quote_t),
              &report_size));
      else
          // Do not support legacy format and raw quote
          OE_RAISE(OE_REPORT_PARSE_ERROR);

      if (evidence_size < report_size)
          OE_RAISE(OE_INCORRECT_REPORT_SIZE);

      // Extract runtime custom claims
      if (has_input_runtime_claims && (evidence_size > report_size))
      {
          uint64_t runtime_claims_offset;
          OE_CHECK(oe_safe_sub_sizet(
              header->data_size, report_size, &runtime_claims_size));
          runtime_claims = (uint8_t*)oe_malloc(runtime_claims_size);
          if (!runtime_claims)
              OE_RAISE(OE_OUT_OF_MEMORY);
          OE_CHECK(oe_safe_add_u64(
              (uint64_t)report, (uint64_t)report_size, &runtime_claims_offset));
          OE_CHECK(oe_memcpy_s(
              runtime_claims,
              runtime_claims_size,
              (void*)runtime_claims_offset,
              runtime_claims_size));
      }

      evidence = (uint8_t*)oe_malloc(evidence_size);
      if (!evidence)
          OE_RAISE(OE_OUT_OF_MEMORY);
      OE_CHECK(oe_memcpy_s(
          evidence, evidence_size, (void*)evidence_with_inittime_claims, evidence_size));

      *output_evidence_buffer = evidence;
      *output_evidence_buffer_size = evidence_size;
      if (has_input_inittime_claims)
      {
          *output_inittime_custom_claims_buffer = inittime_claims;
          *output_inittime_custom_claims_buffer_size = inittime_claims_size;
      }
      if (has_input_runtime_claims)
      {
          *output_runtime_custom_claims_buffer = runtime_claims;
          *output_runtime_custom_claims_buffer_size = runtime_claims_size;
      }

      result = OE_OK;

  done:
      if (result != OE_OK)
      {
          oe_free(evidence);
          oe_free(inittime_claims);
          oe_free(runtime_claims);
      }
      oe_free(evidence_with_inittime_claims);
      return result;
  }
  ```

Discussion and Follow-Up
--------

- Backward compatibility to the existing verification APIs

  The current design does not aim to support backward compatibility to existing verification APIs
  (e.g., `oe_verify_attestation_certificate_with_evidence_v2`), which were designed for the verifier;
  i.e., the proposed APIs are specifically for the attester and the relying party to use, supporting
  the end-to-end attested TLS.

- New relying party APIs for processing the attestation result

  One follow-up work from this proposal is that there currently is no API for the relying
  party to parse the attestation result. The code snippet in the [User Experience](#user-experience)
  presents a potential API. However, the actual API design requires more discussion, which is tracked
  by [#4202](https://github.com/openenclave/openenclave/issues/4202).

- Support multiple sets of custom claims with evidence

  The current format of OE evidence only supports a single custom claim buffer, which is referred to as
  run-time custom claims in this proposal. The conclusion from previous [discussion](InitTimeConfigurationInterface.md)
  on whether to extend the format to support both init- and run-time custom claims was
  keeping the existing format. The main concern on extending the format is the breaking changes
  to the existing attestation framework (e.g., the `oe_verify_evidence` API). This proposal follows
  this spirit that separating out the init- and run-time claims from the evidence, which also aligns
  with the
  [MAA's REST API](https://docs.microsoft.com/en-us/rest/api/attestation/attestation/attest-open-enclave).
  However, in the long-term,
  it may still be desirable to support the evidence with multiple sets of custom claims. This proposal
  leaves this topic as future work.

- Increased size of the certificate

  The support of init-time custom claims, run-time claims, and attestation result inevitably increases
  the size of the certificate. This issue could cause a problem if there is a limitation on the certificate size.
  This topic requires more discussion during the implementation.

Authors
-------

- Ming-Wei Shih <mishih@microsoft.com>
