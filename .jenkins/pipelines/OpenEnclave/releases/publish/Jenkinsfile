// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

/*
This Pipeline will publish an OpenEnclave release from GitHub to public APT and NuGet repositories.
To publish a release:
1) PUBLISH_RELEASE should be set to true and 
2) OE_RELEASE_VERSION should be set to the release version you want to publish.

If PUBLISH_RELEASE is not set, the job will do a dry run.
*/

library "OpenEnclaveJenkinsLibrary@${params.OECI_LIB_VERSION}"


/**
 * Publish OpenEnclave Ubuntu packages to the Microsoft APT repository
 *
 * @param release_version  The version of the Open Enclave release to install
 * @param os_release       The distribution version without "." (e.g. 1804)
 */

def ubuntuReleaseSetup(String os_release) {

    helpers.WaitForAptLock()
    withCredentials([file(credentialsId: 'azure-repoapi-client', variable: 'repoapiclient'),
                     string(credentialsId: 'msft-apt-repo-pem', variable: 'repoclientpem'),
                     string(credentialsId: 'ReleaseAADClientId', variable: 'AADClientId'),
                     string(credentialsId: 'ReleaseAADResource', variable: 'AADResource'),
                     string(credentialsId: 'ReleaseAADTenant', variable: 'AADTenant'),
                     string(credentialsId: "MicrosoftAptRepositoryUbuntu${os_release}", variable: "UbuntuRepoID")]) {
        withEnv(["OS_RELEASE=${os_release}"]) {
            sh '''#!/bin/bash
                set +x
                echo Ubuntu${OS_RELEASE}
                sudo apt-get update
                sudo apt-get -y --no-install-recommends install python3-adal jq

                if ! apt list --installed | grep azure-repoapi-client; then
                    sudo apt -y install ${repoapiclient}
                fi

                # Install repoclient.pem
                if [[ -f ${WORKSPACE}/repoclient.pem ]]; then
                    rm ${WORKSPACE}/repoclient.pem
                fi
                touch ${WORKSPACE}/repoclient.pem
                chmod 600 ${WORKSPACE}/repoclient.pem
                echo ${repoclientpem} | awk 'NF {gsub(/- /, "-\\n"); gsub(/ -/, "\\n-"); printf \$0;}' &>> ${WORKSPACE}/repoclient.pem

                # Install repoclient configuration
                if [[ -f ${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json ]]; then
                    echo "Old config-Ubuntu${OS_RELEASE}.json detected. Removing..."
                    rm ${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json
                fi
                touch ${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json
                chmod 600 ${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json
                jq '.' <<EOF >>${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json
{
    "server": "azure-apt-cat.cloudapp.net",
    "port": "443",
    "AADClientId": "${AADClientId}",
    "AADClientCertificate": "${WORKSPACE}/repoclient.pem",
    "AADResource": "${AADResource}",
    "AADTenant": "${AADTenant}",
    "AADAuthorityUrl": "https://login.microsoftonline.com",
    "repositoryId": "${UbuntuRepoID}"
}
EOF

                # Test repoclient
                repoclient -c ${WORKSPACE}/config-Ubuntu${OS_RELEASE}.json repo list
            '''
        }
    }
}

def release_openenclave(String release_version, String os_release) {
    // Download and publish open-enclave and open-enclave-hostverify packages if PUBLISH_RELEASE is true
    def os_id = 'Ubuntu'
    helpers.releaseDownloadLinux(release_version, "open-enclave", 'GitHub', os_id, os_release)
    helpers.releaseDownloadLinux(release_version, "open-enclave-hostverify", 'GitHub', os_id, os_release)
    sh """#!/bin/bash
        echo "Publishing OpenEnclave ${release_version}"
        repoclient -c ${WORKSPACE}/config-Ubuntu${os_release}.json package add "${WORKSPACE}/${release_version}/${os_id}_${os_release}/${os_id}_${os_release}_open-enclave_${release_version}_amd64.deb"
        repoclient -c ${WORKSPACE}/config-Ubuntu${os_release}.json package add "${WORKSPACE}/${release_version}/${os_id}_${os_release}/${os_id}_${os_release}_open-enclave-hostverify_${release_version}_amd64.deb"
    """
}

def release_mystikos(String release_version, String os_release) {
    def os_id = 'Ubuntu'
    releaseDownloadMystikosLinuxGitHub(release_version, os_id, os_release)
    sh """#!/bin/bash
        echo "Publishing Mystikos ${release_version}"
        repoclient -c ${WORKSPACE}/config-Ubuntu${os_release}.json package add "${WORKSPACE}/${release_version}/${os_id}-${os_release}_mystikos-${release_version}-x86_64.deb"
    """
}

def releaseDownloadMystikosLinuxGitHub(String release_version, String os_id, String os_release) {
    sh """#!/bin/bash -x
        CHANGED=0
        valid_url_regex='^https?://[-A-Za-z0-9\\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\\+&@#/%=~_|]\$'
        ${helpers.WaitForAptLock()}
        sudo apt-get install -y jq
        urls=\$(curl -sS https://api.github.com/repos/deislabs/mystikos/releases/tags/v${release_version} | jq --raw-output --compact-output '.assets | map(.browser_download_url) | .[]')
        for url in \${urls}; do
            # Check if url is valid
            if echo "\${url}" | grep -E '^https?://[-A-Za-z0-9\\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\\+&@#/%=~_|]\$'; then
                # Filter packages specific to current distribution and version
                if echo "\${url}" | grep "${os_id}-${os_release}_mystikos-${release_version}"; then
                    wget --no-verbose --directory-prefix="${release_version}" \${url}
                    if [[ -f "${release_version}/\$(basename \${url})" ]]; then
                        echo "Downloaded to ${release_version}/\$(basename \${url})"
                        CHANGED=1
                    else
                        echo "[Error] Failed to download from \${url}"
                        exit 1
                    fi
                fi
            else
                echo "[Error] Encountered invalid URL: \${url}"
                exit 1
            fi
        done
        if [[ \${CHANGED} -eq 0 ]]; then
            echo "[Error] No files were downloaded!"
            exit 1
        fi
    """
}

pipeline {
    agent {
        label 'nonsgx-ubuntu-2004'
    }
    options {
        timeout(time: 120, unit: 'MINUTES')
        buildDiscarder(
            logRotator(
                artifactNumToKeepStr: '3',
                numToKeepStr: '3'
            )
        )
    }
    parameters {
        string(name: 'REPOSITORY', defaultValue: 'openenclave', description: 'GitHub repository owner name', trim: true)
        string(name: 'BRANCH', defaultValue: 'master', description: 'GitHub repository branch to checkout', trim: true)
        booleanParam(name: "PUBLISH_RELEASE", defaultValue: false, description: 'Publish to public repositories?')
        string(name: "OE_RELEASE_VERSION", defaultValue: '', description: 'Open Enclave Release Version', trim: true)
        string(name: "MYST_RELEASE_VERSION", defaultValue: '', description: 'Open Enclave Release Version', trim: true)
        string(name: "OECI_LIB_VERSION", defaultValue: 'master', description: 'Version of OE Libraries to use', trim: true)
    }
    stages {
        stage('Setup') {
            steps {
                script {
                    ubuntuReleaseSetup('2004')
                    ubuntuReleaseSetup('1804')
                }
            }
        }
        stage('Release OE') {
            when {
                allOf {
                    expression { return params.PUBLISH_RELEASE }
                    expression { return params.OE_RELEASE_VERSION }
                }
            }
            parallel {
                stage('OE - 18.04') {
                    steps {
                        script {
                            release_openenclave(params.OE_RELEASE_VERSION, '1804')
                        }
                    }
                }
                stage('OE - 20.04') {
                    steps {
                        script {
                            release_openenclave(params.OE_RELEASE_VERSION, '2004')
                        }
                    }
                }
            }
        }
        stage('Release Mystikos') {
            when {
                allOf {
                    expression { return params.PUBLISH_RELEASE }
                    expression { return params.MYST_RELEASE_VERSION }
                }
            }
            parallel {
                stage('Mystikos - 18.04') {
                    steps {
                        script {
                            release_mystikos(params.MYST_RELEASE_VERSION, '1804')
                        }
                    }
                }
                stage('Mystikos - 20.04') {
                    steps {
                        script {
                            release_mystikos(params.MYST_RELEASE_VERSION, '2004')
                        }
                    }
                }
            }
        }
        // Todo: Add NuGet stage and function
    }
    post {
        always {
            cleanWs()
        }
    }
}
